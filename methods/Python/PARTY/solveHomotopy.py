# Autogenerated with SMOP version 
# /Users/xupeng.tong/anaconda/bin/smop solver.m
from __future__ import division
from numpy import *
import numpy as np
import time

def SolveHomotopy(A, b, stoppingCriterion=-2, maxtime=8, maxiteration=1e6, tolerance=None):

    global N,gamma_x,z_x,xk_temp,del_x_vec,pk_temp,dk,epsilon,isNonnegative

    t0 = time.time()
    maxiter = 100
    
    verbose = False
    xk_1 = []
    STOPPING_TIME = -2
    STOPPING_GROUND_TRUTH = -1
    STOPPING_DUALITY_GAP = 1
    STOPPING_SPARSE_SUPPORT = 2
    STOPPING_OBJECTIVE_VALUE = 3
    STOPPING_SUBGRADIENT = 4
    STOPPING_DEFAULT = STOPPING_OBJECTIVE_VALUE
    stoppingCriterion = STOPPING_DEFAULT

    maxiter = maxiteration
    isNonnegative=False
    lambda_ = 1e-06

    # Ground truth
    xG = np.zeros((A.shape[1]-1, 1))

    timeSteps = empty((1, maxiter))
    errorSteps = empty((1, maxiter))
    epsSteps = empty((1, maxiter))

    K, N = A.shape
    z_x = zeros((N, 1))
    gamma_x = []
    Primal_constrk = -matmul(A.T, b)

    if isNonnegative:
        c, i = min(Primal_constrk)
        c = max(-c, 0)
    else:
        c, i = argmax(abs(Primal_constrk)), max(abs(Primal_constrk))

    epsilon = c
    nz_x = zeros((N, 1))
    if isempty(xk_1):
        xk_1 = zeros((N, 1))
        gamma_xk = i
    else:
        gamma_xk = find(abs_(xk_1) > eps * 10)
        nz_x[gamma_xk]=1
    f = epsilon * norm(xk_1,1) + 1 / 2 * norm(b - A * xk_1) ** 2
    z_x[gamma_xk]= -sign(Primal_constrk[gamma_xk])
    z_xk = copy(z_x)
    iter_ = 0
    out_x = matlabarray([])
    old_delta = 0
    count_delta_stop = 0
    AtgxAgx = A[:,gamma_xk].T * A[:,gamma_xk]
    iAtgxAgx = inv(A[:,gamma_xk].T * A[:,gamma_xk])

    while iter_ < maxiter:
        iter_ = iter_ + 1
        gamma_x = gamma_xk
        z_x = z_xk
        x_k = xk_1
        del_x = iAtgxAgx * z_x[gamma_x]
        del_x_vec = zeros((N,1))
        del_x_vec[gamma_x] = del_x
        Asupported = A[:,gamma_x]
        Agdelx = Asupported * del_x
        dk = A.T * Agdelx
        pk_temp = copy(Primal_constrk)
        gammaL_temp = find(abs_(abs_(Primal_constrk) - epsilon) < min(epsilon,2 * eps))
        pk_temp[gammaL_temp] = sign(Primal_constrk[gammaL_temp]) * epsilon
        xk_temp = x_k
        xk_temp[abs_(x_k) < 2 * eps] = 0
        i_delta,delta,out_x = update_primal(out_x)
        if old_delta < 4 * eps and delta < 4 * eps:
            count_delta_stop = count_delta_stop + 1
            if count_delta_stop >= 500:
                if verbose:
                    disp(char('stuck in some corner'))
                break
        else:
            count_delta_stop = 0
        old_delta = delta
        xk_1 = x_k + delta * del_x_vec
        Primal_constrk = Primal_constrk + delta * dk
        epsilon_old = epsilon
        epsilon = epsilon - delta
        if epsilon <= lambda_:
            gamma_x0 = find(abs_(xk_1) > 1e-09)
            AtgxAgx0 = A[:,gamma_x0].T * A[:,gamma_x0]
            x_temp = np.linalg.solve(AtgxAgx0,(A[:,gamma_x0].T * b))
            xk_1 = zeros((N,1))
            xk_1[gamma_x0] = x_temp
            timeSteps[iter_] = time.time()-t0
            errorSteps[iter_] = norm(xk_1 - xG)
            epsSteps[iter_] = epsilon
            break
        timeSteps[iter_] = time.time()-t0
        errorSteps[iter_] = norm(xk_1 - xG)
        epsSteps[iter_] = epsilon
        keep_going= True
        if STOPPING_GROUND_TRUTH == stoppingCriterion:
            keep_going = norm(xk_1 - xG) > tolerance
        else:
            if STOPPING_SPARSE_SUPPORT == stoppingCriterion:
                if delta != 0:
                    nz_x_prev=copy(nz_x)
                    nz_x=(abs_(xk_1) > eps * 10)
                    num_nz_x=sum_(nz_x[:])
                    num_changes_active = (sum_(nz_x[:] != nz_x_prev[:]))
                    if num_nz_x >= 1:
                        criterionActiveSet = num_changes_active / num_nz_x
                        keep_going = (criterionActiveSet > tolerance)
            else:
                if STOPPING_DUALITY_GAP == stoppingCriterion:
                    error(char('Duality gap is not a valid stopping criterion for Homotopy.'))
                else:
                    if STOPPING_OBJECTIVE_VALUE == stoppingCriterion:
                        if delta != 0:
                            prev_f=copy(f)
                            f=lambda_ * norm(xk_1,1) + 1 / 2 * norm(b - Asupported * xk_1[gamma_x]) ** 2
                            keep_going=(abs_((prev_f - f) / prev_f) > tolerance)
                    else:
                        if STOPPING_SUBGRADIENT == stoppingCriterion:
                            keep_going = norm(delta * del_x_vec) > tolerance
                        else:
                            if STOPPING_TIME == stoppingCriterion:
                                keep_going = timeSteps[iter_] < maxTime
                            else:
                                error(char('Undefined stopping criterion'))
        if not keep_going:
            break
        if not isempty(out_x):
            len_gamma = len(gamma_x)
            outx_index = find(gamma_x == out_x[1])
            gamma_x[outx_index] = gamma_x[len_gamma]
            gamma_x[len_gamma] = out_x[1]
            gamma_x = gamma_x[1:len_gamma - 1]
            gamma_xk = copy(gamma_x)
            rowi = copy(outx_index)
            colj = copy(outx_index)
            AtgxAgx_ij = copy(AtgxAgx)
            temp_row = AtgxAgx_ij[rowi,:]
            AtgxAgx_ij[rowi,:] = AtgxAgx_ij[len_gamma,:]
            AtgxAgx_ij[len_gamma,:] = temp_row
            temp_col = AtgxAgx_ij[:,colj]
            AtgxAgx_ij[:,colj] = AtgxAgx_ij[:,len_gamma]
            AtgxAgx_ij[:,len_gamma] = temp_col
            iAtgxAgx_ij = copy(iAtgxAgx)
            temp_row = iAtgxAgx_ij[colj,:]
            iAtgxAgx_ij[colj,:] = iAtgxAgx_ij[len_gamma,:]
            iAtgxAgx_ij[len_gamma,:] = temp_row
            temp_col = iAtgxAgx_ij[:,rowi]
            iAtgxAgx_ij[:,rowi] = iAtgxAgx_ij[:,len_gamma]
            iAtgxAgx_ij[:,len_gamma] = temp_col
            AtgxAgx = AtgxAgx_ij[1:len_gamma - 1,1:len_gamma - 1]
            n = size(AtgxAgx_ij,1)
            Q11 = iAtgxAgx_ij[1:n - 1,1:n - 1]
            Q12 = iAtgxAgx_ij[1:n - 1,n]
            Q21 = iAtgxAgx_ij[n,1:n - 1]
            Q22 = iAtgxAgx_ij[n,n]
            Q12Q21_Q22 = Q12 * (Q21 / Q22)
            iAtgxAgx = Q11 - Q12Q21_Q22
            xk_1[out_x[1]] = 0
        else:
            gamma_xk = matlabarray(cat([gamma_x],[i_delta]))
            new_x = copy(i_delta)
            AtgxAnx = A[:,gamma_x].T * A[:,new_x]
            AtgxAgx_mod = matlabarray(cat([AtgxAgx,AtgxAnx],[AtgxAnx.T,A[:,new_x].T * A[:,i_delta]]))
            AtgxAgx = copy(AtgxAgx_mod)
            n = size(AtgxAgx,1)
            iA11 = copy(iAtgxAgx)
            iA11A12 = iA11 * AtgxAgx[1:n - 1,n]
            A21iA11 = AtgxAgx[n,1:n - 1] * iA11
            S = AtgxAgx[n,n] - AtgxAgx[n,1:n - 1] * iA11A12
            Q11_right = iA11A12 * (A21iA11 / S)
            iAtgxAgx = zeros(n)
            iAtgxAgx[1:n - 1,1:n - 1] = iA11 + Q11_right
            iAtgxAgx[1:n - 1,n] = -iA11A12 / S
            iAtgxAgx[n,1:n - 1] = -A21iA11 / S
            iAtgxAgx[n,n] = 1 / S
            xk_1[i_delta] = 0
        z_xk = zeros((N,1))
        z_xk[gamma_xk] = -sign(Primal_constrk[gamma_xk])
        Primal_constrk[gamma_x] = sign(Primal_constrk[gamma_x]) * epsilon

    total_iter = iter_
    x_out = xk_1
    timeSteps = timeSteps[1:total_iter]
    errorSteps = errorSteps[1:total_iter]
    epsSteps = epsSteps[1:total_iter]

    return x_out,total_iter,timeSteps,errorSteps,epsSteps

def update_primal(out_x=None,*args,**kwargs):
    global N,gamma_x,z_x,xk_temp,del_x_vec,pk_temp,dk,epsilon,isNonnegative

    gamma_lc = setdiff(arange(1,N),union(gamma_x,out_x))
    if isNonnegative:
        delta1 = copy(inf)
    else:
        delta1_constr = (epsilon - pk_temp[gamma_lc]) / (1 + dk[gamma_lc])
        delta1_pos_ind = find(delta1_constr > 0)
        delta1_pos = delta1_constr[delta1_pos_ind]
        delta1,i_delta1 = min(delta1_pos)
        if isempty(delta1):
            delta1 = copy(inf)

    delta2_constr = (epsilon + pk_temp[gamma_lc]) / (1 - dk[gamma_lc])
    delta2_pos_ind = find(delta2_constr > 0)
    delta2_pos = delta2_constr[delta2_pos_ind]
    delta2,i_delta2 = min(delta2_pos)

    if isempty(delta2):
        delta2 = copy(inf)
    if delta1 > delta2:
        delta = copy(delta2)
        i_delta = gamma_lc[delta2_pos_ind[i_delta2]]
    else:
        delta = copy(delta1)
        i_delta = gamma_lc[delta1_pos_ind[i_delta1]]
    delta3_constr = (-xk_temp[gamma_x] / del_x_vec[gamma_x])
    delta3_pos_index = find(delta3_constr > 0)
    delta3,i_delta3 = min(delta3_constr[delta3_pos_index])
    out_x_index = gamma_x[delta3_pos_index[i_delta3]]
    out_x = []

    if not isempty(delta3) and (delta3 > 0) and (delta3 <= delta):
        delta = delta3
        out_x = copy(out_x_index)

    xk_1 = xk_temp + delta*del_x_vec
    xk_1[out_x] = 0
    wrong_sign = find(sign(xk_1[gamma_x]).dot(z_x[gamma_x]) == -1)

    if isNonnegative:
        wrong_sign = union(wrong_sign,find(xk_1[gamma_x] < 0))

    if not isempty(gamma_x[wrong_sign]):
        delta = 0
        val_wrong_x,ind_wrong_x = sort(abs_(del_x_vec[gamma_x[wrong_sign]]),char('descend'))
        out_x = gamma_x[wrong_sign[ind_wrong_x]]
    i_delta_temp = gamma_lc[abs_(pk_temp[gamma_lc] + delta*dk[gamma_lc]) - (epsilon-delta) >= 10*eps]

    if not isempty(i_delta_temp):
        i_delta_more = copy(i_delta_temp)

        if (len(i_delta_more) >= 1) and (not any((i_delta_temp == i_delta))):
            v_temp,i_temp = max(- pk_temp[i_delta_more] / dk[i_delta_more])
            i_delta = i_delta_more[i_temp]
            delta = 0
            out_x = []

    return i_delta,delta,out_x


